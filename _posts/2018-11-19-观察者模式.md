---
update: 1544355239066
title: 观察者模式
maker: gitpress
---
<p>常听到各种设计模式，然后也一直没有去了解。</p>
<p>近期在一个单页程序里想要加一个登录后触发的一个钩子，做成钩子是想要方便管理，以及后续可能会有其他的周期钩子。</p>
<p>于是我想到了jq的trigger可以自定义事件，然后on去监听触发。但是这个项目没有使用jq，所以需要自己实现一个触发器。</p>
<p>参看了别人的代码，发现别人管这个叫观察者模式。</p>
<p>附上思路、大致代码。</p>
<p>trigger('key', arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 触发器，调用与key值相对应的函数</p>
<p>on('key', cb)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为key值添加一个函数，trigger触发时将调用</p>
<p>off('key', cb)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取消绑定key值对应的函数</p>
<p>现在思路已经很明显了，建一个数组，调用on的时候就往里push回调函数，调用trigger时就根据key值找到对应的数组，调用数组函数。</p>
<p>这样就可以同时触发多个与key相关联的函数，这么想wordpress里的do_action好像也是这样，do_action触发，add_action添加，remove_action取消。</p>
<pre class="language-javascript"><code>
class Observers {
    constructor() {
        this.evs = {}
    }

    on(key, cb) {
        if ( !this.evs[key] ) {
            this.evs[key] = []
        }
        this.evs[key].push(cb)
    }

    trigger() {
        const args = [...arguments]
        const key = args.shift()

        if ( !this.evs[key] ) {
            return
        }
        for ( let i of this.evs[key] ) {
            i.apply(this, args)
        }
    }

    off(key, cb) {
        if ( !this.evs[key] ) {
            return
        }
        if ( !cb ) {
            delete this.evs[key]
        } else {

            const index = this.evs[key].includes(cb)
            this.evs[key].splice(index, 1)
        }
    }
}

export default Observers
</code></pre>
<p>&nbsp;</p>